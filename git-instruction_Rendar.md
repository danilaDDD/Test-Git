# Первый файл по контрою версии (README.md)
## Начнем знакомтсов с контролем версии!

![JavaScript](./JS.png) - 
  Яызк на котором я специализируюсь

  Самый хороший ресурс со спецификацией - [Тут](https://es5.javascript.ru/index.html).


### Выделение текста
*Для выделения* _текста курсивом_

**Полуж** __ирный__

_**Полужирный курсив**_

***Жирный курсив***

Колоборация всего этого: 

## Списки 

* Элемент 1
* Элемент 2
* Элемент 3
+ Элемент 3.1
+ Элемент 3.2

1. Первый элемент
2. Второй элемент
3. Третий элемент




## Действия в GitBash - Контроль версии: ##
### Коммиты можно проверить в папке по пути Folder/.git/logs/HEAD ###
### Для написания в два слова необходимо: git add firsWord\ secondWord.md ###
- после изменений в репозитории мы создаем commitl;
- git log - выводит список сохранений commits и id его. Можено использовать git log --graph;
- после вызова git log commit можно восстановить по id commit => git checkout id мы возвращаемся в нужный commit (можем при помощи первых 4рех символов)
- выйти из git log = клавиша 'q';
- между версиями можно спокойно переключаться
- для возвращения в актуальное состояние версии, (а не через checout id) нужно: git checkout master (master - это название ветки в которой работаешь. Оно может быть любым);
- git diff покажет разницу между текущей и последней сохраненной версией(Если ничего comit-ел в последнее время, то он ничего не покажет, но если ты commit, то покажет изменения в файлах между крайним коммитом и текущем состоянии);
- git checkout nameBranch - переход по веткам (можно создавать черновики и т.д.);
- git branch - выводит список веток;
- git branch -m new_branch - Переименовать ветку

### - После создания новой ветки и внесения изменений, мы находимся в той же (новой ветке), но после перехода в старую, изменения не будут проихсодить, т.е. все что было в новой ветке, там и остается. ###
### - При вызове git log в старой ветке (основной), то новую ветку видеть не будем. ###
### - При переходе в основную ветку, можем создавать еще новую(2) ветку и производить изменения уже в ней ###
### ИТОГ: Мы имеем основную ветку и 2 второстепенных. При вызове git log в основной, мы не видим изменения новых ветках. ###

**- ДЛЯ СЛИЯНИЯ ВЕТОК, после полной готовки новой ветки используется команда _"git merge ИМЯ ВЕТКИ"_**
После основная ветка примет все изменения, которые были в новой ветке. Соответственно после слияния веток, мы можем **удалить** ту ветку, которую сливали, чтоб не было путаницы: ***"git branch -d ИМЯ ВЕТКИ"***. После проверки ***git branch*** остануться только те ветки, которые еще в процессе работы

В git обычно не добавляется в систему контроля версии (типа картинки и т.д.)

Создаем файл ***.gitignore***, для пропуска файлов в контроль(желательно в корневой ветке). 

Команды для gitignore:
 - .idea.
 - npm node_modules
 - .log
 - **/node_modules
 - **/.vs/


## Что делать, если информация в двух ветках (текст) разная: конфликт слияния ##
- Оставить текущую версию
- Оставить новую (пришедшую) версию
- Оставить оба варианта - Просто после слияния, сам редактируешь (так как нужно) => просто commit новой версии с уже всеми слияниями и изменениями
- Сравнение двух вариантов

# Работа с удаленными репозиториями:

## Для подключаения к чужому рпозиторию на GitHub нужно: ##
  - Зайти в репозиторий и скопировать ссылку на SVN
  - git clone адрес ссылки - произойдет скачивание 

## Создание репозитория и связывание его с GitHub: ##
  - git remote add origin "https://url.git" (origin это название репозитория).
  - git branch -M main - сделать галуню ветку "main".
  - git push -u origin main - отправить изменения в репозиторий  "push" - толкнуть в репозиторий origin.

  После нам необходима авторизация.
  
## Работа с GitHub: ##
Если мне нужно работать с нескольких ПК или с совместной разработке то:

- git pull (тянуть) - скачать с репозитория актуальную версию (оно merge нашего репозитория с серверными ветками).
- В GitHub можно чрез кнопку Fork скопировать репозиторий на полную в свой репозиторий, для работы с ним

Порядок работы с чужим проектом:
- Создается новая ветка git branch new_branch
- Переходим в эту ветку
- Производим изменения в этой ветке, которые нам необходимо сделать
- git push (Отправить в свой репозиторий, котрый скопировали "Fork-нули")
- на GitHub можно нажать ***Compare & pull request*** (предложение слить репозитории для общей разработке)
